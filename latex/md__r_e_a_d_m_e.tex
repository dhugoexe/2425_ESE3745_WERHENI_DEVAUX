\chapter{L\textquotesingle{}objectifs}
\hypertarget{md__r_e_a_d_m_e}{}\label{md__r_e_a_d_m_e}\index{L\textquotesingle{}objectifs@{L\textquotesingle{}objectifs}}
\label{md__r_e_a_d_m_e_autotoc_md0}%
\Hypertarget{md__r_e_a_d_m_e_autotoc_md0}%


A partir d\textquotesingle{}un hacheur complet et d\textquotesingle{}une carte Nucleo-\/\+STM32\+G474\+RE, nous devons \+:

-\/R√©aliser un shell pour commander le hacheur.

-\/R√©aliser la commande des 4 transistors du hacheur en commande compl√©mentaire d√©cal√©e.

-\/Faire l\textquotesingle{}acquisition des diff√©rents capteurs.

-\/R√©aliser l\textquotesingle{}asservissement en temps r√©el.\hypertarget{md__r_e_a_d_m_e_autotoc_md1}{}\doxysection{\texorpdfstring{TP1 Commande MCC basique}{TP1 Commande MCC basique}}\label{md__r_e_a_d_m_e_autotoc_md1}
L\textquotesingle{}objectif est de g√©n√©rer quatre signaux PWM en commande compl√©mentaire d√©cal√©e afin de contr√¥ler le moteur en boucle ouverte tout en respectant les sp√©cifications du cahier des charges. Il s\textquotesingle{}agit √©galement d\textquotesingle{}inclure un temps mort entre les commutations des transistors pour √©viter les courts-\/circuits. Les signaux de commande devront √™tre v√©rifi√©s √† l\textquotesingle{}oscilloscope pour s\textquotesingle{}assurer de leur conformit√©. Parall√®lement, une prise en main du hacheur sera effectu√©e, suivie d\textquotesingle{}un premier essai de commande du moteur.\hypertarget{md__r_e_a_d_m_e_autotoc_md2}{}\doxysection{\texorpdfstring{1-\/G√©n√©ration de 4 PWM}{1-\/G√©n√©ration de 4 PWM}}\label{md__r_e_a_d_m_e_autotoc_md2}
Nous allons g√©n√©rer quatre signaux PWM sur les bras de pont U et V pour contr√¥ler le hacheur, en utilisant le timer d√©j√† assign√© √† ces broches. Conform√©ment au cahier des charges, la fr√©quence de la PWM doit √™tre de 20 k\+Hz, avec un temps mort minimum √† d√©terminer en fonction des sp√©cifications de la datasheet des transistors (la valeur devra √™tre valid√©e). De plus, une r√©solution minimale de 10 bits est requise pour assurer un contr√¥le pr√©cis.

\hypertarget{md__r_e_a_d_m_e_autotoc_md3}{}\doxysection{\texorpdfstring{Configuration de pin}{Configuration de pin}}\label{md__r_e_a_d_m_e_autotoc_md3}
Nous utiliserons le Timer 1 (TIM1) pour g√©n√©rer les signaux PWM principaux sur les broches PA9 et PA8, ainsi que leurs signaux compl√©mentaires sur les broches PA14 et PA13, comme le montre la figure ci-\/dessous

\hypertarget{md__r_e_a_d_m_e_autotoc_md4}{}\doxysection{\texorpdfstring{Configuration de Timer1}{Configuration de Timer1}}\label{md__r_e_a_d_m_e_autotoc_md4}
La configuration des broches dans STM32\+Cube\+MX est r√©alis√©e en activant le TIM1 et en assignant les canaux PWM (CH1, CH2, CH1N, CH2N) aux broches correspondantes, comme illustr√© dans la figure.

\hypertarget{md__r_e_a_d_m_e_autotoc_md5}{}\doxysection{\texorpdfstring{Calcul de PRSC (Prescaler) pour une fr√©quence PWM de 20 k\+Hz}{Calcul de PRSC (Prescaler) pour une fr√©quence PWM de 20 k\+Hz}}\label{md__r_e_a_d_m_e_autotoc_md5}
L\textquotesingle{}√©quation de base pour calculer la fr√©quence d\textquotesingle{}une PWM est donn√©e par \+:



o√π \+:

-\/f\+PWM est la fr√©quence de la PWM (20 k\+Hz dans ce cas)

-\/f\+CLK est la fr√©quence de l\textquotesingle{}horloge (170 MHz)

-\/PSC est le prescaler (valeur recherch√©e)

-\/ARR est l\textquotesingle{}Auto-\/\+Reload Register (0 ici).



Finalement, PSC \+: PSC=8500‚àí1=8499

\hypertarget{md__r_e_a_d_m_e_autotoc_md6}{}\doxysection{\texorpdfstring{\texorpdfstring{$\ast$}{*}\+Calcule de temps mort}{\texorpdfstring{$\ast$}{*}\+Calcule de temps mort}}\label{md__r_e_a_d_m_e_autotoc_md6}
Nous allons commencer par calculer la p√©riode d\textquotesingle{}oscillation √† partir de la fr√©quence, en utilisant la formule \+: ‚Äã 

Ensuite, d\textquotesingle{}apr√®s la datasheet des transistors, nous prenons le temps de retard de conduction ùëádfg √©gal √† 100 ns Pour calculer le temps mort nous divisons le temps de retard ùëádfg par la p√©riode d\textquotesingle{}oscillation ùëá





Pour obtenir un rapport cyclique de 60 \%, nous avons modifi√© les registres CCR1 du Timer 1 et CCR2 du Timer 2. Les r√©sultats de cette configuration sont illustr√©s dans la figure ci-\/dessous \+:



D√©monstation de temps mort egale a 100ns sur l\textquotesingle{}oscilloscope\+:

\hypertarget{md__r_e_a_d_m_e_autotoc_md7}{}\doxysection{\texorpdfstring{Commande de vitesse}{Commande de vitesse}}\label{md__r_e_a_d_m_e_autotoc_md7}
Pour controler la vitesse du moteur, nous allons envoyer une s√©quence via la liaison UART (par l\textquotesingle{}USB) de la forme \+:speed XXXX

Le traitement de cette chaine de caract√®re se faire de la mani√®re suivant \+: -\/D√©tection des premiers caract√®res "{}speed"{} -\/Conversion de tous les caract√®res repr√©sentant des chiffres XXXX en nombre entier -\/V√©rification de la valeur (si la valeur est sup√©rieur au maximum autoris√© (bien sp√©cifier cette valeur), on l\textquotesingle{}abaisse √† cette valeur), -\/Application de cette vitesse au moteur √† travers le registre g√©rant le rapport cyclique de la PWM

\hypertarget{md__r_e_a_d_m_e_autotoc_md8}{}\doxysection{\texorpdfstring{Les Probl√®mes potentiels que nous allons observ√©s \+:}{Les Probl√®mes potentiels que nous allons observ√©s \+:}}\label{md__r_e_a_d_m_e_autotoc_md8}
-\/Instabilit√© \+: Le changement brutal de puissance peut provoquer des oscillations ou des comportements impr√©visibles.

-\/Surchauffe \+: Si le courant augmente trop rapidement, cela peut provoquer une surchauffe dans certains composants (transistors, r√©sistances, etc.).

-\/√Ä-\/coups \+: Pour un moteur, une variation brutale du rapport cyclique peut entra√Æner des mouvements brusques, causant des contraintes m√©caniques ou un manque de pr√©cision.\hypertarget{md__r_e_a_d_m_e_autotoc_md9}{}\doxysection{\texorpdfstring{Solution \+:}{Solution \+:}}\label{md__r_e_a_d_m_e_autotoc_md9}
Nous allons g√©n√©rer une mont√©e progressive du rapport cyclique afin d\textquotesingle{}atteindre la vitesse cible. Nous commen√ßons par tester si la vitesse sp√©cifi√©e respecte les limites d√©finies par les constantes MAX\+\_\+\+SPEED et MIN\+\_\+\+SPEED. Si la valeur d√©passe la limite maximale, elle est plafonn√©e √† MAX\+\_\+\+SPEED. Inversement, si elle est inf√©rieure √† la limite minimale, elle est ajust√©e pour correspondre √† MIN\+\_\+\+SPEED. Une fois valid√©e, la vitesse est appliqu√©e au syst√®me en utilisant la fonction set\+Speed, et la vitesse r√©ellement appliqu√©e est stock√©e dans la variable current\+Speed.



La fonction set\+Speed(uint8\+\_\+t speed) ajuste progressivement la vitesse actuelle (current\+Speed) vers la vitesse cible (speed). Si la vitesse cible est sup√©rieure, elle augmente current\+Speed √©tape par √©tape, en ajustant les registres CCR1 et CCR2 pour moduler le rapport cyclique. Si la vitesse cible est inf√©rieure, elle r√©duit current\+Speed de mani√®re similaire. √Ä chaque incr√©ment ou d√©cr√©ment, un d√©lai de 100 ms est ajout√© pour garantir une transition fluide. Une fois la vitesse cible atteinte, la fonction retourne la vitesse actuelle.

\hypertarget{md__r_e_a_d_m_e_autotoc_md10}{}\doxysection{\texorpdfstring{Conclusion}{Conclusion}}\label{md__r_e_a_d_m_e_autotoc_md10}
√Ä partir de ce TP, nous allons g√©n√©rer quatre signaux PWM en compl√©mentaire d√©cal√©e pour contr√¥ler le moteur en boucle ouverte, tout en respectant le cahier des charges. Cela inclut l\textquotesingle{}ajout du temps mort et la mise en place d\textquotesingle{}une commande progressive de la vitesse du moteur.\hypertarget{md__r_e_a_d_m_e_autotoc_md11}{}\doxysection{\texorpdfstring{TP2 Commande en boucle ouverte, mesure de Vitesse et de courant}{TP2 Commande en boucle ouverte, mesure de Vitesse et de courant}}\label{md__r_e_a_d_m_e_autotoc_md11}
Dans cette partie Nous devons \+:

-\/Commander en boucle ouverte le moteur avec une acc√©l√©ration limit√©e, -\/Mesurer le courant aux endroits ad√©quat dans le montage, -\/Mesurer la vitesse √† partir du codeur pr√©sent sur chaque moteur.

\hypertarget{md__r_e_a_d_m_e_autotoc_md12}{}\doxysubsection{\texorpdfstring{Commandes de vitesse}{Commandes de vitesse}}\label{md__r_e_a_d_m_e_autotoc_md12}
Rajouter quelques fonctionnalit√©s √† votre projet \+:

\texorpdfstring{$\ast$}{*}\+Commande start \+: permet de fixer le rapport cyclique √† 50\% (vitesse nulle) et d\textquotesingle{}activer la g√©n√©ration des pwm (HAL\+\_\+\+TIM\+\_\+\+PWM\+\_\+\+Start et HAL\+\_\+\+TIMEx\+\_\+\+PWMN\+\_\+\+Start),



-\/\texorpdfstring{$>$}{>}Ce code d√©marre un syst√®me PWM lorsque la commande "{}start"{} est d√©tect√©e. Il active les signaux PWM sur deux canaux du timer htim1 avec un rapport cyclique de 50 \%. Ensuite, il met √† jour une variable current\+Speed pour indiquer une vitesse de fonctionnement de 50 \%.

\texorpdfstring{$\ast$}{*}\+Commande stop \+: permet de d√©sactiver la g√©n√©ration des PWM.



Ce code arr√™te le syst√®me PWM lorsque la commande "{}stop"{} est d√©tect√©e. Il d√©sactive les signaux PWM sur les canaux 1 et 2 du timer htim1

Commande speed XXXX \+: permet de d√©finir le rapport cyclique √† XXXX/\+PWM\+\_\+\+MAX, mais afin de r√©duire l\textquotesingle{}appel √† courant, Nous devons √©tablir une mont√©e progressive √† cette vitesse en quelques secondes.



Resultat sur Tera Terminal\+: \hypertarget{md__r_e_a_d_m_e_autotoc_md13}{}\doxysection{\texorpdfstring{Pour Start\+:}{Pour Start\+:}}\label{md__r_e_a_d_m_e_autotoc_md13}
\hypertarget{md__r_e_a_d_m_e_autotoc_md14}{}\doxysection{\texorpdfstring{Pour Stop\+:}{Pour Stop\+:}}\label{md__r_e_a_d_m_e_autotoc_md14}
\hypertarget{md__r_e_a_d_m_e_autotoc_md15}{}\doxysection{\texorpdfstring{Pour Speed=40}{Pour Speed=40}}\label{md__r_e_a_d_m_e_autotoc_md15}
\hypertarget{md__r_e_a_d_m_e_autotoc_md16}{}\doxysection{\texorpdfstring{Pour Speed=60}{Pour Speed=60}}\label{md__r_e_a_d_m_e_autotoc_md16}
\hypertarget{md__r_e_a_d_m_e_autotoc_md17}{}\doxysection{\texorpdfstring{2 Mesure du courant}{2 Mesure du courant}}\label{md__r_e_a_d_m_e_autotoc_md17}
\hypertarget{md__r_e_a_d_m_e_autotoc_md18}{}\doxysection{\texorpdfstring{les fonctions de transfert des capteurs de mesure de courant (lecture datasheet)}{les fonctions de transfert des capteurs de mesure de courant (lecture datasheet)}}\label{md__r_e_a_d_m_e_autotoc_md18}
Une fonction de transfert √©tablit une relation entre le courant mesur√© par un capteur et la tension de sortie qu\textquotesingle{}il g√©n√®re, permettant ainsi de convertir les lectures analogiques en valeurs physiques exploitables. Dans ce cas, la tension ùëà est d\textquotesingle{}abord calcul√©e √† partir de la valeur brute de l\textquotesingle{}ADC gr√¢ce √† la formule \+:



o√π 3.\+3V repr√©sente la tension de r√©f√©rence et 4096 correspond √† la r√©solution du convertisseur analogique-\/num√©rique (12 bits). Ensuite, la tension ùëà est reli√©e au courant I via l\textquotesingle{}√©quation caract√©ristique du capteur \+:



o√π 1.\+65V est l\textquotesingle{}offset pour un courant nul, et 0.\+05 V/A est la sensibilit√© du capteur.\hypertarget{md__r_e_a_d_m_e_autotoc_md19}{}\doxysection{\texorpdfstring{les pin du stm32 utilis√©s pour faire ces mesures de courant}{les pin du stm32 utilis√©s pour faire ces mesures de courant}}\label{md__r_e_a_d_m_e_autotoc_md19}
La broche PA2 est utilis√©e pour mesurer le courant dans le circuit. Elle est configur√©e en entr√©e analogique et reli√©e √† un convertisseur analogique-\/num√©rique (ADC) du STM32, permettant de convertir le signal analogique du capteur de courant en une valeur num√©rique exploitable par le microcontr√¥leur.\hypertarget{md__r_e_a_d_m_e_autotoc_md20}{}\doxysection{\texorpdfstring{Etablir une premi√®re mesure de courant avec les ADC en Pooling.}{Etablir une premi√®re mesure de courant avec les ADC en Pooling.}}\label{md__r_e_a_d_m_e_autotoc_md20}
Ce code mesure le courant en utilisant un ADC en mode polling et transmet le r√©sultat via l\textquotesingle{}UART. Apr√®s avoir d√©marr√© et attendu la fin de la conversion avec HAL\+\_\+\+ADC\+\_\+\+Start et HAL\+\_\+\+ADC\+\_\+\+Poll\+For\+Conversion, la valeur brute de l\textquotesingle{}ADC est lue et convertie en tension, puis en courant √† l\textquotesingle{}aide de la fonction de transfert. Le courant calcul√© est ensuite format√© et transmis via HAL\+\_\+\+UART\+\_\+\+Transmit pour affichage

\hypertarget{md__r_e_a_d_m_e_autotoc_md21}{}\doxysection{\texorpdfstring{Configuration de pin ADC1}{Configuration de pin ADC1}}\label{md__r_e_a_d_m_e_autotoc_md21}
\hypertarget{md__r_e_a_d_m_e_autotoc_md22}{}\doxysection{\texorpdfstring{Resultat sur Tera Term}{Resultat sur Tera Term}}\label{md__r_e_a_d_m_e_autotoc_md22}
\hypertarget{md__r_e_a_d_m_e_autotoc_md23}{}\doxysection{\texorpdfstring{Mesure √† interval de temps r√©gulier avec la mise en place d\textquotesingle{}une la chaine d\textquotesingle{}acquisition Timer/\+ADC/\+DMA.}{Mesure √† interval de temps r√©gulier avec la mise en place d\textquotesingle{}une la chaine d\textquotesingle{}acquisition Timer/\+ADC/\+DMA.}}\label{md__r_e_a_d_m_e_autotoc_md23}
\hypertarget{md__r_e_a_d_m_e_autotoc_md24}{}\doxysection{\texorpdfstring{Configuratn de l\textquotesingle{}ADC}{Configuratn de l\textquotesingle{}ADC}}\label{md__r_e_a_d_m_e_autotoc_md24}




\hypertarget{md__r_e_a_d_m_e_autotoc_md25}{}\doxysection{\texorpdfstring{Interuption}{Interuption}}\label{md__r_e_a_d_m_e_autotoc_md25}
Ce callback g√®re la fin d\textquotesingle{}une conversion ADC en mode DMA. Il calcule la moyenne des valeurs ADC stock√©es dans le buffer, met √† jour une variable d\textquotesingle{}√©tat pour signaler la fin de la conversion, et d√©sactive le DMA. Une notification est √©galement envoy√©e via l\textquotesingle{}UART pour signaler la compl√©tion.

\hypertarget{md__r_e_a_d_m_e_autotoc_md26}{}\doxysection{\texorpdfstring{Resultat sur Tera Term}{Resultat sur Tera Term}}\label{md__r_e_a_d_m_e_autotoc_md26}
\hypertarget{md__r_e_a_d_m_e_autotoc_md27}{}\doxysection{\texorpdfstring{3-\/Mesure de vitesse}{3-\/Mesure de vitesse}}\label{md__r_e_a_d_m_e_autotoc_md27}
Pour Mesure de vitesse de Rotation Nous Allons utulis√© la pin PA6 et PA4 a l\textquotesingle{}aide de Timer3\hypertarget{md__r_e_a_d_m_e_autotoc_md28}{}\doxysection{\texorpdfstring{Configuration de Timer 3}{Configuration de Timer 3}}\label{md__r_e_a_d_m_e_autotoc_md28}
\hypertarget{md__r_e_a_d_m_e_autotoc_md29}{}\doxysection{\texorpdfstring{Code de mesure de Vitesse}{Code de mesure de Vitesse}}\label{md__r_e_a_d_m_e_autotoc_md29}
La fonction Encoder\+\_\+\+Init initialise le mode encodeur du timer htim1 avec HAL\+\_\+\+TIM\+\_\+\+Encoder\+\_\+\+Start, permettant de commencer √† compter les impulsions provenant de l\textquotesingle{}encodeur. Elle enregistre √©galement la derni√®re valeur du compteur et le temps correspondant pour des calculs ult√©rieurs.



La fonction Encoder\+\_\+\+Get\+Filtered\+Speed calcule une vitesse filtr√©e \+: elle r√©cup√®re la vitesse brute avec Encoder\+\_\+\+Get\+Speed, stocke cette valeur dans un buffer circulaire de taille FILTER\+\_\+\+SIZE, et calcule la moyenne des valeurs du buffer. Cette moyenne est ensuite retourn√©e, fournissant une mesure de vitesse liss√©e pour minimiser l\textquotesingle{}impact des fluctuations instantan√©es.

\hypertarget{md__r_e_a_d_m_e_autotoc_md30}{}\doxysection{\texorpdfstring{Conclusion}{Conclusion}}\label{md__r_e_a_d_m_e_autotoc_md30}
Dans ce TP, nous allons commander le moteur en boucle ouverte tout en limitant l\textquotesingle{}acc√©l√©ration afin d\textquotesingle{}assurer un d√©marrage progressif et de minimiser les variations brusques de courant. Ensuite, nous mesurerons le courant aux points strat√©giques du montage pour analyser la consommation en fonction des conditions de fonctionnement. Enfin, la vitesse sera mesur√©e √† l\textquotesingle{}aide du Encodeur.\hypertarget{md__r_e_a_d_m_e_autotoc_md31}{}\doxysection{\texorpdfstring{TP3 Asservissement}{TP3 Asservissement}}\label{md__r_e_a_d_m_e_autotoc_md31}
L\textquotesingle{}objectif de cette partie est d\textquotesingle{}√©tablir l\textquotesingle{}asservissement du moteur, tant en vitesse qu\textquotesingle{}en courant. Nous devons d\textquotesingle{}abord mettre en place un syst√®me de r√©gulation de la vitesse du moteur afin de garantir qu\textquotesingle{}il suive la consigne d√©finie, en utilisant un contr√¥leur adapt√©, comme un PID. Ensuite, il est n√©cessaire de r√©guler le courant pour √©viter les surcharges et assurer un fonctionnement optimal du moteur, en ajustant la commande en fonction de la mesure du courant r√©el. Ces deux asservissements permettront de maintenir des performances stables et fiables du moteur dans diff√©rentes conditions de fonctionnement.

Pour ce faire, vous pouvez utiliser un contr√¥leur PID ou un contr√¥leur √† deux boucles (vitesse et courant). Voici les grandes √©tapes \+:\hypertarget{md__r_e_a_d_m_e_autotoc_md32}{}\doxysection{\texorpdfstring{Asservissement en vitesse du moteur \+:}{Asservissement en vitesse du moteur \+:}}\label{md__r_e_a_d_m_e_autotoc_md32}
Nous Utiliseons le codeur du moteur pour obtenir la vitesse en temps r√©el (en comptant les impulsions sur une p√©riode donn√©e).

\texorpdfstring{$\ast$}{*}\+Calcul de l\textquotesingle{}erreur de vitesse \+: Comparez la vitesse mesur√©e avec la consigne de vitesse Vconsigne,L\textquotesingle{}erreur de vitesse ùëíùë£ sera \+:



Un contr√¥leur PID est utilis√© pour ajuster la commande du moteur en fonction de l\textquotesingle{}erreur de vitesse. Le contr√¥leur PID se compose de trois termes \+:

-\/Proportionnel (P) \+: Correction proportionnelle √† l\textquotesingle{}erreur.

-\/Int√©gral (I) \+: Compensation de l\textquotesingle{}erreur accumul√©e au fil du temps.

-\/D√©riv√© (D) \+: Att√©nuation des variations rapides ou des oscillations.

L\textquotesingle{}algorithme PID ajuste la commande pour r√©duire l\textquotesingle{}erreur √† z√©ro et stabiliser la vitesse du moteur, en offrant un contr√¥le pr√©cis et r√©actif.\hypertarget{md__r_e_a_d_m_e_autotoc_md33}{}\doxysection{\texorpdfstring{Asservissement en courant du moteur \+:}{Asservissement en courant du moteur \+:}}\label{md__r_e_a_d_m_e_autotoc_md33}
L‚Äôasservissement en courant est essentiel pour r√©guler la puissance d√©livr√©e au moteur, en particulier afin d\textquotesingle{}√©viter les surcharges et de garantir un fonctionnement stable. En r√®gle g√©n√©rale, l\textquotesingle{}asservissement en courant peut √™tre effectu√© en boucle ouverte pour une r√©gulation simple ou en boucle ferm√©e avec un contr√¥leur PID, comme c\textquotesingle{}est le cas pour notre application.

\texorpdfstring{$\ast$}{*}\+Calcul de l\textquotesingle{}erreur de courant \+:

Comparez le courant mesur√© avec la consigne de courant Iconsigne. L\textquotesingle{}erreur de courant ùëíùëê sera\+:



Un contr√¥leur PID (ou un contr√¥leur proportionnel dans certains cas) est ensuite utilis√© pour ajuster la commande de courant. Ce contr√¥leur permet de moduler le signal PWM appliqu√© au moteur, afin de r√©guler le courant et de maintenir la valeur d√©sir√©e en fonction de l\textquotesingle{}erreur mesur√©e.\hypertarget{md__r_e_a_d_m_e_autotoc_md34}{}\doxysection{\texorpdfstring{Conclusion}{Conclusion}}\label{md__r_e_a_d_m_e_autotoc_md34}
La conclusion de cette partie est que l\textquotesingle{}asservissement en vitesse et en courant est essentiel pour assurer un contr√¥le pr√©cis et stable du moteur. L\textquotesingle{}asservissement en vitesse permet de maintenir la vitesse du moteur √† la valeur souhait√©e, en ajustant le signal de commande via un contr√¥leur PID. De m√™me, l\textquotesingle{}asservissement en courant r√©gule la puissance d√©livr√©e au moteur, √©vitant ainsi les surcharges et garantissant des performances optimales. Ces deux boucles de contr√¥le, bas√©es sur les mesures de la vitesse et du courant, contribuent √† un fonctionnement fiable et s√©curis√© du moteur dans diverses conditions d\textquotesingle{}exploitation. 